<!doctype html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bootstrap demo</title>
    <link href="../vendor/twbs/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet">
</head>

<body class="container py-5">

<script src="../vendor/components/jquery/jquery.min.js"></script>
<script src="../vendor/twbs/bootstrap/dist/js/bootstrap.bundle.min.js"></script>
<script src="../dist/bs-color-picker.js"></script>
<script>
    $(function () {
        function createColorPicker(initialColor) {
            const container = document.createElement('div');
            container.style.display = 'flex';
            container.style.flexDirection = 'column';
            container.style.gap = '10px';
            container.style.padding = '10px';

            function createFilledColorWheel() {
                const size = 200;          // Größe des Farbfelds bleibt gleich
                const sliderWidth = 14;    // Breite des Hue-Sliders bleibt gleich
                const padding = 10;        // Padding bleibt gleich
                const previewSize = 50;    // GEÄNDERT: von 200 auf 50 reduziert
                const totalWidth = previewSize + padding + size + sliderWidth + padding;

                const canvas = document.createElement('canvas');
                canvas.width = totalWidth;
                canvas.height = size;
                const context = canvas.getContext('2d');

                let currentHue = 0;
                let currentSaturation = 1;
                let currentValue = 1;
                let activeControl = null;

                function getMousePosition(e) {
                    const rect = canvas.getBoundingClientRect();
                    // Skalierungsfaktor berechnen
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;

                    // Mausposition relativ zur Canvas berechnen und skalieren
                    const x = (e.clientX - rect.left) * scaleX;
                    const y = (e.clientY - rect.top) * scaleY;

                    console.log('Canvas Position:', rect);
                    console.log('Scale factors:', {scaleX, scaleY});
                    console.log('Mouse relative to canvas:', {x, y});

                    return {x, y};
                }

                function handleHueClick(pos) {
                    const relativeY = Math.max(0, Math.min(size - 1, pos.y));
                    currentHue = (relativeY / (size - 1)) * 360;
                    updateColor();
                }

                function getClickedArea(x) {
                    // Da wir jetzt relativ zur Canvas sind:
                    // Vorschau ist von 0 bis previewSize
                    // Farbfeld beginnt bei previewSize + padding
                    // Hue-Slider beginnt nach dem Farbfeld
                    if (x >= previewSize + padding && x < previewSize + padding + size) {
                        return 'color';
                    }
                    if (x >= previewSize + padding + size + padding && x < previewSize + padding + size + padding + sliderWidth) {
                        return 'hue';
                    }
                    return 'none';
                }


                function drawMarker(x, y, isHueSlider = false) {
                    x = Math.max(previewSize + padding + (isHueSlider ? size + padding + sliderWidth / 2 : 6),
                        Math.min(x, previewSize + padding + (isHueSlider ? totalWidth - 6 : size - 6)));
                    y = Math.max(6, Math.min(y, size - 6));

                    context.beginPath();
                    context.arc(x, y, 6, 0, 2 * Math.PI);
                    context.strokeStyle = 'white';
                    context.lineWidth = 2;
                    context.stroke();
                    context.beginPath();
                    context.arc(x, y, 5, 0, 2 * Math.PI);
                    context.strokeStyle = 'black';
                    context.lineWidth = 1;
                    context.stroke();
                }

                function drawPreview(color) {
                    // Schachbrettmuster für Transparenz
                    for (let x = 0; x < previewSize; x += 10) {
                        for (let y = 0; y < previewSize; y += 10) {
                            context.fillStyle = (x + y) % 20 === 0 ? '#fff' : '#eee';
                            context.fillRect(x, y, 10, 10);
                        }
                    }

                    context.fillStyle = color;
                    context.fillRect(0, 0, previewSize, previewSize);

                    context.strokeStyle = '#000';
                    context.lineWidth = 1;
                    context.strokeRect(0, 0, previewSize, previewSize);
                }

                function drawMainSquare(baseHue) {
                    const imageData = context.createImageData(size, size);
                    for (let y = 0; y < size; y++) {
                        for (let x = 0; x < size; x++) {
                            const s = x / (size - 1);
                            const v = 1 - (y / (size - 1));
                            const rgb = HSVtoRGB(baseHue, s, v);
                            const idx = (y * size + x) * 4;
                            imageData.data[idx] = rgb.r;
                            imageData.data[idx + 1] = rgb.g;
                            imageData.data[idx + 2] = rgb.b;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                    context.putImageData(imageData, previewSize + padding, 0);
                }

                function drawHueSlider() {
                    const imageData = context.createImageData(sliderWidth, size);
                    for (let y = 0; y < size; y++) {
                        const hue = (y / (size - 1)) * 360;
                        const rgb = HSVtoRGB(hue, 1, 1);
                        for (let x = 0; x < sliderWidth; x++) {
                            const idx = (y * sliderWidth + x) * 4;
                            imageData.data[idx] = rgb.r;
                            imageData.data[idx + 1] = rgb.g;
                            imageData.data[idx + 2] = rgb.b;
                            imageData.data[idx + 3] = 255;
                        }
                    }
                    context.putImageData(imageData, previewSize + padding + size + padding, 0);
                }

                function handleColorAreaClick(pos) {
                    // HIER: Debug-Ausgabe hinzufügen
                    console.log('Color click raw position:', pos);

                    const colorAreaX = pos.x - (previewSize + padding);
                    const relativeY = pos.y;

                    // HIER: Debug-Ausgabe der berechneten Position
                    console.log('Color click calculated position:', {
                        colorAreaX,
                        relativeY,
                        previewSize,
                        padding
                    });

                    const s = Math.max(0, Math.min(1, colorAreaX / size));
                    const v = Math.max(0, Math.min(1, 1 - (relativeY / size)));

                    currentSaturation = s;
                    currentValue = v;
                    updateColor();
                }

                function handleColorAreaClick(pos) {
                    // HIER: Debug-Ausgabe hinzufügen
                    console.log('Color click raw position:', pos);

                    const colorAreaX = pos.x - (previewSize + padding);
                    const relativeY = pos.y;

                    // HIER: Debug-Ausgabe der berechneten Position
                    console.log('Color click calculated position:', {
                        colorAreaX,
                        relativeY,
                        previewSize,
                        padding
                    });

                    const s = Math.max(0, Math.min(1, colorAreaX / size));
                    const v = Math.max(0, Math.min(1, 1 - (relativeY / size)));

                    currentSaturation = s;
                    currentValue = v;
                    updateColor();
                }

                function updateColor() {
                    context.clearRect(0, 0, totalWidth, size);

                    const rgb = HSVtoRGB(currentHue, currentSaturation, currentValue);
                    const hexColor = RGBtoHex(rgb.r, rgb.g, rgb.b);

                    drawPreview(hexColor);
                    drawMainSquare(currentHue);
                    drawHueSlider();

                    const mainX = previewSize + padding + (currentSaturation * size);
                    const mainY = (1 - currentValue) * size;
                    drawMarker(mainX, mainY);

                    const hueY = (currentHue / 360) * size;
                    drawMarker(previewSize + padding + size + padding + sliderWidth / 2, hueY, true);

                    canvas.dispatchEvent(new CustomEvent('colorchange', {
                        detail: {
                            hex: hexColor,
                            rgb: rgb,
                            hsv: {h: currentHue, s: currentSaturation, v: currentValue}
                        }
                    }));
                }

                // Optional: Debug-Ausgabe hinzufügen
                canvas.addEventListener('mousedown', function (e) {
                    const pos = getMousePosition(e);
                    const area = getClickedArea(pos.x);
                    console.log('Relative click position:', pos);
                    console.log('Clicked area:', area);
                    console.log('Canvas dimensions:', {
                        width: canvas.width,
                        height: canvas.height
                    });

                    if (area === 'color') {
                        activeControl = 'color';
                        handleColorAreaClick(pos);
                    } else if (area === 'hue') {
                        activeControl = 'hue';
                        handleHueClick(pos);
                    }
                });

                document.addEventListener('mousemove', function (e) {
                    if (!activeControl) return;

                    const pos = getMousePosition(e);
                    if (activeControl === 'color') {
                        handleColorAreaClick(pos);
                    } else if (activeControl === 'hue') {
                        handleHueClick(pos);
                    }
                });

                document.addEventListener('mouseup', function () {
                    activeControl = null;
                });

                canvas.updateFromHSV = function (h, s, v) {
                    currentHue = h;
                    currentSaturation = s;
                    currentValue = v;
                    updateColor();
                };

                updateColor();
                return canvas;
            }

            const colorWheel = createFilledColorWheel();

            function setColor(initialColor) {
                try {
                    let rgb;
                    let hsv;
                    let alpha = 1;

                    if (typeof initialColor === 'string') {
                        if (initialColor.startsWith('#')) {
                            rgb = hexToRGB(initialColor);
                        } else if (initialColor.includes(',')) {
                            // Prüfe auf rgba Format
                            const rgbaMatch = initialColor.match(/rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,?\s*([0-9.]+)?\s*\)/);
                            if (rgbaMatch) {
                                rgb = {
                                    r: parseInt(rgbaMatch[1]),
                                    g: parseInt(rgbaMatch[2]),
                                    b: parseInt(rgbaMatch[3])
                                };
                                alpha = rgbaMatch[4] ? parseFloat(rgbaMatch[4]) : 1;
                            } else {
                                const values = initialColor.split(',').map(v => parseFloat(v.trim()));
                                if (values.length >= 3) {
                                    if (values[0] <= 360 && values[1] <= 100 && values[2] <= 100) {
                                        // HSV Format
                                        hsv = {
                                            h: values[0],
                                            s: values[1] / 100,
                                            v: values[2] / 100
                                        };
                                    } else {
                                        // RGB/RGBA Format
                                        rgb = { r: values[0], g: values[1], b: values[2] };
                                        if (values.length > 3) {
                                            alpha = values[3];
                                        }
                                    }
                                }
                            }
                        } else {
                            // Benannte Farbe
                            const temp = document.createElement('div');
                            temp.style.color = initialColor;
                            document.body.appendChild(temp);
                            const computedColor = window.getComputedStyle(temp).color;
                            document.body.removeChild(temp);

                            const match = computedColor.match(/\d+/g);
                            if (match) {
                                rgb = {
                                    r: parseInt(match[0]),
                                    g: parseInt(match[1]),
                                    b: parseInt(match[2])
                                };
                            }
                        }

                        // Konvertiere RGB zu HSV wenn nötig
                        if (rgb && !hsv) {
                            hsv = RGBtoHSV(rgb.r, rgb.g, rgb.b);
                        }
                    }

                    if (hsv) {
                        colorWheel.updateFromHSV(hsv.h, hsv.s, hsv.v);
                        // Wichtig: Aktualisiere auch die Eingabefelder
                        updateAllFormats(rgb || HSVtoRGB(hsv.h, hsv.s, hsv.v));
                    }
                } catch (e) {
                    console.error('Ungültiges Farbformat:', e);
                }
            }



            container.appendChild(colorWheel);

            const inputsContainer = document.createElement('div');
            inputsContainer.style.display = 'flex';
            inputsContainer.style.gap = '10px';
            inputsContainer.style.flexWrap = 'wrap';
            inputsContainer.style.marginTop = '10px';

            const inputs = {
                hex: createInputGroup('HEX', '#ff0000'),
                rgb: createInputGroup('RGB', '255, 0, 0'),
                cmyk: createInputGroup('CMYK', '0, 100, 100, 0'),
                hsv: createInputGroup('HSV', '0, 100, 100'),
                hsl: createInputGroup('HSL', '0, 100, 50')
            };

            Object.values(inputs).forEach(group => inputsContainer.appendChild(group.container));
            container.appendChild(inputsContainer);


            if (initialColor) {
                setColor(initialColor);
            }

            function createInputGroup(label, placeholder) {
                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.flexDirection = 'column';
                container.style.gap = '5px';

                const labelElement = document.createElement('label');
                labelElement.textContent = label;
                labelElement.style.fontWeight = 'bold';

                const input = document.createElement('input');
                input.type = 'text';
                input.placeholder = placeholder;
                input.style.width = '150px';
                input.style.padding = '5px';

                container.appendChild(labelElement);
                container.appendChild(input);

                return {container, input};
            }

            // Farbkonvertierungsfunktionen
            function HSVtoRGB(h, s, v) {
                let r, g, b;
                const i = Math.floor(h / 60);
                const f = h / 60 - i;
                const p = v * (1 - s);
                const q = v * (1 - f * s);
                const t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0:
                        r = v;
                        g = t;
                        b = p;
                        break;
                    case 1:
                        r = q;
                        g = v;
                        b = p;
                        break;
                    case 2:
                        r = p;
                        g = v;
                        b = t;
                        break;
                    case 3:
                        r = p;
                        g = q;
                        b = v;
                        break;
                    case 4:
                        r = t;
                        g = p;
                        b = v;
                        break;
                    case 5:
                        r = v;
                        g = p;
                        b = q;
                        break;
                }

                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }

            function RGBtoHSV(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const d = max - min;
                let h, s = (max === 0 ? 0 : d / max), v = max;

                if (max === min) {
                    h = 0;
                } else {
                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h *= 60;
                }

                return {h, s, v};
            }

            function RGBtoHex(r, g, b) {
                const toHex = (n) => {
                    const hex = Math.round(n).toString(16);
                    return hex.length === 1 ? '0' + hex : hex;
                };
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            }

            function hexToRGB(hex) {
                hex = hex.replace('#', '');
                if (hex.length === 3) {
                    hex = hex.split('').map(h => h + h).join('');
                }
                const r = parseInt(hex.slice(0, 2), 16);
                const g = parseInt(hex.slice(2, 4), 16);
                const b = parseInt(hex.slice(4, 6), 16);
                if (isNaN(r) || isNaN(g) || isNaN(b)) throw new Error('Ungültiges HEX-Format');
                return {r, g, b};
            }

            function RGBtoHSL(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;

                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;

                if (max === min) {
                    h = s = 0;
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

                    switch (max) {
                        case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;
                        case g:
                            h = (b - r) / d + 2;
                            break;
                        case b:
                            h = (r - g) / d + 4;
                            break;
                    }
                    h *= 60;
                }

                return {h, s, l};
            }

            function RGBtoCMYK(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;

                const k = 1 - Math.max(r, g, b);
                const c = (1 - r - k) / (1 - k) || 0;
                const m = (1 - g - k) / (1 - k) || 0;
                const y = (1 - b - k) / (1 - k) || 0;

                return {
                    c: Math.round(c * 100),
                    m: Math.round(m * 100),
                    y: Math.round(y * 100),
                    k: Math.round(k * 100)
                };
            }

            Object.entries(inputs).forEach(([format, group]) => {
                group.input.addEventListener('change', (e) => {
                    updateFromInput(format, e.target.value);
                });
            });

            function updateFromInput(sourceFormat, value) {
                let rgb;
                let hsv;

                try {
                    switch (sourceFormat) {
                        case 'hex':
                            rgb = hexToRGB(value);
                            hsv = RGBtoHSV(rgb.r, rgb.g, rgb.b);
                            break;
                        case 'rgb':
                            const [r, g, b] = value.split(',').map(n => parseInt(n.trim()));
                            rgb = {r, g, b};
                            hsv = RGBtoHSV(r, g, b);
                            break;
                        case 'hsv':
                            const [h, s, v] = value.split(',').map(n => parseFloat(n.trim()));
                            hsv = {h, s: s / 100, v: v / 100};
                            rgb = HSVtoRGB(h, s / 100, v / 100);
                            break;
                        case 'cmyk':
                            const [c, m, y, k] = value.split(',').map(n => parseFloat(n.trim()));
                            const cmyk = {c, m, y, k};
                            rgb = cmykToRGB(cmyk);
                            hsv = RGBtoHSV(rgb.r, rgb.g, rgb.b);
                            break;
                        case 'hsl':
                            const [hh, ss, l] = value.split(',').map(n => parseFloat(n.trim()));
                            const hsl = {h: hh, s: ss / 100, l: l / 100};
                            rgb = hslToRGB(hsl);
                            hsv = RGBtoHSV(rgb.r, rgb.g, rgb.b);
                            break;
                    }

                    colorWheel.updateFromHSV(hsv.h, hsv.s, hsv.v);
                } catch (e) {
                    console.error('Ungültiges Format:', e);
                }
            }

            function updateAllFormats(rgb) {
                const hex = RGBtoHex(rgb.r, rgb.g, rgb.b);
                const hsv = RGBtoHSV(rgb.r, rgb.g, rgb.b);
                const hsl = RGBtoHSL(rgb.r, rgb.g, rgb.b);
                const cmyk = RGBtoCMYK(rgb.r, rgb.g, rgb.b);

                inputs.hex.input.value = hex;
                inputs.rgb.input.value = `${rgb.r}, ${rgb.g}, ${rgb.b}`;
                inputs.hsv.input.value = `${Math.round(hsv.h)}, ${Math.round(hsv.s * 100)}, ${Math.round(hsv.v * 100)}`;
                inputs.hsl.input.value = `${Math.round(hsl.h)}, ${Math.round(hsl.s * 100)}, ${Math.round(hsl.l * 100)}`;
                inputs.cmyk.input.value = `${cmyk.c}, ${cmyk.m}, ${cmyk.y}, ${cmyk.k}`;
            }

            function cmykToRGB({c, m, y, k}) {
                c /= 100;
                m /= 100;
                y /= 100;
                k /= 100;

                const r = Math.round(255 * (1 - c) * (1 - k));
                const g = Math.round(255 * (1 - m) * (1 - k));
                const b = Math.round(255 * (1 - y) * (1 - k));

                return {r, g, b};
            }

            function hslToRGB({h, s, l}) {
                let r, g, b;

                if (s === 0) {
                    r = g = b = l;
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1 / 6) return p + (q - p) * 6 * t;
                        if (t < 1 / 2) return q;
                        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                        return p;
                    };

                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;

                    r = hue2rgb(p, q, (h / 360 + 1 / 3));
                    g = hue2rgb(p, q, (h / 360));
                    b = hue2rgb(p, q, (h / 360 - 1 / 3));
                }

                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }

            colorWheel.addEventListener('colorchange', function (e) {
                updateAllFormats(e.detail.rgb);
            });

            return container;
        }
        const picker = createColorPicker('#f0f');
        const wrapper = document.createElement('div');
        wrapper.style.width = '500px';  // Fixe Breite
        wrapper.style.height = 'auto';  // Höhe automatisch anpassen
        wrapper.style.position = 'relative';
        wrapper.appendChild(picker);
        // container.appendChild(wrapper);

// Verwendung:

        document.body.appendChild(wrapper);

    });


</script>
</body>
</html>
